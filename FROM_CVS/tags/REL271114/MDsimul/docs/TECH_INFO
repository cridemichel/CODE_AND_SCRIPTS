---------------------************************************---------------------
-------------------***** MDSIMUL TECHNICAL INFORMATIONS *****-----------------
----------------********* De Michele Cristiano 1997 (C) ******** -------------
-------------------***************************************** -----------------


0. OVERVIEW 


When the simulation starts analyzes the arguments and can choose two ways:

1) continuing a previously interrupted simulation .

2) beginning a new simulation.

In the first case the program reads a restore file ( the good one, see later )
and continues the simulation.
Instead in the second case reads the parameters from the file specified as the
second argumets ( for ex. mdsimul -f <pars file> ).
If the are no coordinates file spcified in, i.e. there is a line of this kind:
inifile: *, or there isn't it initialize the coordinates arrays placing the
particles on a FCC lattice and giving them adequate velocities. 
After the startup the process fork and the simulation begins. 
  

1. COORDINATES FILES ( '.cor' files) 


A '.cor' file is made as follows:
						       
                         _____________________________ 
                     	|   _______________________   |
                        |  |     struct params     |  |
                        |  |_______________________|  | 
                        |   _______________________   |
                        |  |       particles       |  |
                        |  |      coordinates      |  |
                        |  |_______________________|  |
                        |_____________________________|
	       	     
The structure params contains informations about simulation parameters such as
the number of particles (parnum), the temporal step length (steplength), the
total steps of the simulations and the actual simulation step.


2. RESTORE FILES

				                       
A restore files is maden as follows :		       
						       
                         _____________________________ 
                     	|   _______________________   |
                        |  |     struct params     |  |
                        |  |_______________________|  | 
                        |   _______________________   |
                        |  |   struct progStatus   |  |
                        |  |_______________________|  | 
	                |                             |
			|   _______________________   |
                        |  |       particles       |  |
                        |  |      coordinates      |  |
                        |  |_______________________|  |
                        |_____________________________|

The structure 'progStatus' contains all the informations needed by the program 
to restart and not contained in 'params' structure, note that the last one 
is put at the top of the coordinates file and that for examples can't contain
the name of the final coordinate file, for example.  
 

3. 'simStatus' STRUCTURE 


This structure is stored in the file STATUS_FILE and contains informations 
needed by 'chkStatus' to continue the simulation after a stop due 
to a system crash. 
It has three attributes:

- curStep = current simulation step
  This is not the real actual step but instead the last step at which 
  the simulation has update the file  STATUS_FILE.

- running = 1 means that the simulation is proceeding, 0 that it is stopped.
  If a system crash is happened then running attribute value is 1 and the 
  step counter cur_step is stop.
  Anyway if the user has pressed CTRL_Z the running attribute is 0 and the 
  step counter is stop, in this case to restart the simulation you must type:
    mdsimul -continue 
  That is you must restart it manually. <<<-----------CHANGED !!!!!!!

- totTime = total time of the simulation.  
  


4. SYSTEM CRASH


4.1 Restarting  

After a system crash if the system alarm (crond) invokes periodically 
the executable 'chkStatus' the simulation is able to restart ( see SIMUL_INFO
for details).
The 'chkStatus' program reads simulation status from the file STATUS_FILE, if
the attribute running is true (!=0) and if the attribute curStep does not
change in time then chekStatus restart simulation with the command:
mdsimul -continue (see SIMUL_INFO).
  
4.2 Restore file loading

To continue a previuosly interrupted simulation it is necessary to load a 
restore file.
There are two restore files and if a system crash is happend, then most recent
is probably corrupted, so a valid criterion is to choose the longer file.
The rightness of this choice follows from two facts:
- when a restore file is written is length is set to zero,i.e. the file is 
  trucanted to zero length.
  This is done by setting the O_TRUNC flag when opening the file for writing.
- if a system crash occurs during writing the restore file, then, probably, 
  not all the datas was stored into the file.

The complete algorithm used to decide which restore file to load is
(the whichGood() procedure make this choice):
	  
  ________________
 |  ERROR OPENING | Y
 |   BOTH FILE?   |---> EXIT(-1)
 |________________|          
        | N		     
        v       	     
  ________________	        	       
 |   BOTH STAT    | Y	        	       
 |    FAILED ?    |---> EXIT(-1)             RESTART 
 |________________|                          SIMULATION	  
       | N 	                	       ^       
       v                        	       | N     
   ____________        ______________      ______________ 
  |  ONE FILE  |  Y   | LOAD THE     |    | ERROR READING|            
  | NOT OPENED?|----> | OTHER ONE    |--->| OR CLOSING?  |--> EXIT(-1)
  |____________|      |______________|    |______________|             
       | N                                     	                       
       v    	                               	        	       
  _____________        ____________      _______________               
 | IS ONE FILE |  Y   | LOAD       |    | ERROR READING	| y            
 |   LONGER?   |----> | LONGEST ONE|--->| OR CLOSING?   |---> EXIT(-1) 
 |_____________|      |____________|    |_______________|              
       | N		        	         | N                   
       v        	        		 v                     
  ___________________       ___________         RESTART SIM.	       
 |   IS ONE FILE     | Y   | LOAD MOST |        	       		       
 |   MORE(*) RECENT ?|---->|   RECENT  |---> _______________           
 |___________________|     |___________|    | ERROR READING | N	       
                                    	    | OR CLOSING?   |-->CONTINUE 
(*) time1 >= time 2 so the answer is        |_______________|   SIMUL.
    always yes                                     | Y	     
                                                   v  	                     
       	       	                             _______________   	    	     
                       	       	       	    |  TRY OTHER    | OK 
               				    |    FILE       |--> CONT. SIM.  
       	        			    |_______________|
                                                        | ERROR	       	     
						        v    
		                                       EXIT(-1)
4.4 Choosing the measure files

The measure files are every time double saved, that is if we have a certain 
measure and the measure file name is 'pippo' (Ofilenames.dataFiles[]), 
the simulation, during saving, put it into the files 'pippo0' and 'pippo1'.
To restart safely is better if we choose as the first file to save into, the
one corrupted.
The complete algorithm to choose this file is the same as the previuos one.
In fact there is in mdsimul a function, which choice among two files 
the good one, using the algorithm in 4.4.  							     

4.5 Choosing the status file after restarting		     
							     
When the simulation tries to restart after a system crash, it must be choose
the "right" status file.
Suppose that a system crash happens when it is writing the status file then 
this file can be corrupted, imagine it is so and that the simulation choose
the other status file to write on, after restarting. 
Now if the system crashes again and the last status file is corrupted too then,
the simulation couldn't restart again.
So from this we deduce that the simulation must choose the corrupted status 
file to save in, after it is restarted. 
This choice is made by this algorithm:

         ________________      __________________
        | ARE BOTH FILES | Y  | ONE FILE         | Y   ______________
        | CORRUPTED ?    |--> | NOT CLOSED ONLY? |--> |USE THE OTHER |
        |________________|    |__________________|    |   FILE       |
                 | N                  | N             |______________|
                 v                    v				      
             _______________        _____________________________      
            | CHOOSE THE     |      | CONTINUE HOPING             |
            | CORRUPTED ONE  |      | A CRASH DOESN'T OCCURR AGAIN|
            |_______________ |      |_____________________________|
								  
4.4 Saving restore informations					  
								  
All the file manipulation operations are maden by the father process, the 
child must only calculate new particle coordinates concurrently.  
								  
4.5 Automagic restart						  
								  
After the system crash, the computer reboots, if the alarm, manipulated by 
the crond daemon, is programmed opportunely ( by crontab -e, see SIMUL_INFO), 
then every X minutes check if an mdsimul was interrupted and eventually
restart it.							  
The algorithm used by the checkStatus program (this is his name),is as
follows:							  
       _______________	     _______________			  
      |  CHK_FILE     |  N  | READ GOOD	    | ERROR	  
      |   EXIST ?     |---->| STATUS FILE   |-----> EXIT
      |_______________|     |_______________|
           | Y                     | OK                 
           v                       v
    _______________            _________________
   |  LOAD CHECK   | 	      |	SAVE CHECK FILE | ERROR   _________________
   |     FILE      |          |_________________| -----> | UNLINK CHK_FILE |
   |_______________|                   | OK              |_________________|
           |                           v                          |
           v                          EXIT                        v
    ________________                                            EXIT
   |  LOAD STATUS   |   ERROR    _________________  
   | FILE INDICATED | --------> |UNLINK CHK_FILE  |       
   | IN CHECK FILE  |           |_________________|
   |________________|                    |
           | OK                          v
           v                            EXIT
   __________________
  | IS THE SIMULATION|
  |    GOING ON ?    | ---> RESTART SIMULATION
  |__________________|
           | Y
           v
         EXIT

	
5. PARALLEL PROCESSING


5.1 How it works

After the simulation started and all the parameters are read, the process forks
and we have two one, a father and a child.
They use the shared memory blocks where the coordinates are stored in, and 
concurrently make calculations.
This can be understood by the following figure:

begin (&x1[0])-------->  -------------   <--------- FATHER starts here and
                     	|   x1[0]     |             comes down 
                   /    |     .       |                |
                  |     |     .       |                v
     SHARED ARRAY |     |     .       |        FATHER AND CHILD 
     (new coord.) |     |     .       |         HURT EACH OTHER      
                   \    |             |                ^
                        |   x1[N]     |                |
end   ---------------->  -------------   <--------- CHILD starts here and 
                                                    comes up

Where the shared array is one coordinates array (there are severale arrays 
of this kind depending upon the coordinates number) to be updated using the 
old coordinates.
The updating process is maden concurrently, meaning that the two process 
update the array until they 'hurt' each other.       
                 

5.2 Shared Counters


   _____________________________________________________________________
  |  Child  ->  scN_[0] -> scN = scN_[0] (inside loop(scN){ ... } )     |
  |                                                                     |
  |  Father ->  scN_[1] -> scN = scN_[1] (inside loop(scN){ ... } )     |
  |_____________________________________________________________________|                                                 
                               Table 5.1
Consider the Table 5.1, every process has 10 'shared coounter' named scN_[i]
with N = 0...9  and i = 0, 1 depending on the process.
Each array scN_[] is shared, so each process can read the counter of the other
one.
With setSc(scN, N) macro you can initilize the shared counter in fact, for
example:
  setSc(sc0, N) => sc0_[0] = N - 1 (in the child) and 
	           sc0_[1] = 0 (in the father )
After initialization of a counter you must syncronize processes, because if 
a process has set its counter, it must be sure that the other process 
has set its counter, too.

EXAMPLE: 
A typical move() procedure look like this:

  /* intialization of */
  setSc(sc0, N);

  ProcSync0();

  loopShr(sc0)
    {
       ...code...
    } 

6. MEASURE FILES 


Measure files contains the variuos measure performed dunring simulation, their 
structure is quite simple:

                         _____________________________ 
                     	|   _______________________   |
                        |  |    struct measHead    |  |
                        |  |_______________________|  | 
                        |   _______________________   |
                        |  |                       |  |
			|  |       measures        |  |
                        |  |                       |  |
			|  |_______________________|  |
                        |_____________________________|

Where struct measHead is a structure defined in mdsimul.h.
For example suppose that you save measure 'pippo' every 5 steps, that 
every mesure is 4 bytes long and that every measure is a FLOAT,
 then you have the following file:


                         _____________________________ 
 struct measHed HEADER:	|   _______________________   |
 measHead.saveSteps --> |  |         5             |  | <-- unsigned int 
 measHead.size      --> |  |         4             |  | <-- unsgned int
		        |  |_______________________|  |
                        |   _______________________   |
                        |  |       12.566          |  | <-- FLOAT = 4 bytes 
			|  |       11.555          |  |
                        |  |       .	           |  |
			|  |       .	           |  |
			|  |       .	           |  |
			|  |_______________________|  |
                        |_____________________________|

If you want to  plot data you must convert them in suitable form 
( some utilities are furnished, see SIMUL_INFO )

7. TAPE FILE 

A tape file is of this form:
                         _____________________________ 
                     	|   _______________________   |
                        |  |    struct xvaHead     |  |
                        |  |_______________________|  | 
                        |   _______________________   |
                        |  |                       |  |
			|  |       measures        |  |
                        |  |                       |  |
			|  |_______________________|  |
                        |_____________________________|

Each measure consiste of a subsetof all coordinates, specified in the XVA_LIST
in mdsimdep.h.
