!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.5.4	//
ALLOC_LIST	nmpoly.h	112;"	d
Aa	nmpoly.h	/^  psi1c, psi2c, sqrtdr2, Aa, DrSqTot, DphiSq, GsAng[GSANGPOINT], Fs[FSPOINT],$/;"	v
Aalpha	xvautil.h	/^COORD_TYPE *drSq, *dphiSq, *Dr, *Dt, *ddtdrSq, *ddtdphiSq, *Aalpha, *dr4,$/;"	v
AalphaFile	xvautil.h	/^  AalphaFile[128], GselfFile[128], GsGsgaussFile[128], FselfFile[128],$/;"	v
AalphaFlag	xvautil.h	/^  ddtdrFlag = 1, ddtdphiFlag = 1, AalphaFlag = 1, GselfFlag = 1,$/;"	v
Allocate	hetero.c	/^void Allocate(int totSize, COORD_TYPE** pointer, ...)$/;"	f
Allocate	jumps.c	/^void Allocate(int totSize, COORD_TYPE** pointer, ...)$/;"	f
Allocate	wtd.c	/^void Allocate(int totSize, COORD_TYPE** pointer, ...)$/;"	f
Allocate	xvautil.c	/^void Allocate(int totSize, COORD_TYPE** pointer, ...)$/;"	f
BodeTerm	move.c	/^COORD_TYPE BodeTerm(COORD_TYPE dt, COORD_TYPE* fi)$/;"	f
BuildNebrList	forces.c	/^void BuildNebrList(int Nm, COORD_TYPE rCut) $/;"	f
BuildNebrListNoLinked	forces.c	/^void BuildNebrListNoLinked(int Nm, COORD_TYPE rCut) $/;"	f
C1File	xvautil.h	/^char velFile[128], psi1File[128], psi2File[128], C1File[128], C2File[128], $/;"	v
C1Flag	xvautil.h	/^int velFlag=1, psi1Flag=1, psi2Flag=1, vhFlag=1, C1Flag=1, C2Flag=1, C3Flag=1,$/;"	v
C1acf	xvautil.h	/^COORD_TYPE *velacf, *psi1acf, *psi2acf, *C1acf, *C2acf, *C3acf, $/;"	v
C1c	nmpoly.h	/^COORD_TYPE Ptens[3], DQtens[3], C1c, C2c, C3c, C4c, velc, Gs[GSPOINT], $/;"	v
C2File	xvautil.h	/^char velFile[128], psi1File[128], psi2File[128], C1File[128], C2File[128], $/;"	v
C2Flag	xvautil.h	/^int velFlag=1, psi1Flag=1, psi2Flag=1, vhFlag=1, C1Flag=1, C2Flag=1, C3Flag=1,$/;"	v
C2acf	xvautil.h	/^COORD_TYPE *velacf, *psi1acf, *psi2acf, *C1acf, *C2acf, *C3acf, $/;"	v
C2c	nmpoly.h	/^COORD_TYPE Ptens[3], DQtens[3], C1c, C2c, C3c, C4c, velc, Gs[GSPOINT], $/;"	v
C3File	xvautil.h	/^  C3File[128], C4File[128], dphiSqFile[128], drSqFile[128], DtFile[128], $/;"	v
C3Flag	xvautil.h	/^int velFlag=1, psi1Flag=1, psi2Flag=1, vhFlag=1, C1Flag=1, C2Flag=1, C3Flag=1,$/;"	v
C3acf	xvautil.h	/^COORD_TYPE *velacf, *psi1acf, *psi2acf, *C1acf, *C2acf, *C3acf, $/;"	v
C3c	nmpoly.h	/^COORD_TYPE Ptens[3], DQtens[3], C1c, C2c, C3c, C4c, velc, Gs[GSPOINT], $/;"	v
C4File	xvautil.h	/^  C3File[128], C4File[128], dphiSqFile[128], drSqFile[128], DtFile[128], $/;"	v
C4Flag	xvautil.h	/^  phiFlag=1, C4Flag=1, dphiSqFlag=1, drSqFlag=1, DtFlag=1, DrFlag=1, $/;"	v
C4acf	xvautil.h	/^  *C4acf, *wtd;$/;"	v
C4c	nmpoly.h	/^COORD_TYPE Ptens[3], DQtens[3], C1c, C2c, C3c, C4c, velc, Gs[GSPOINT], $/;"	v
CMreset	nmpoly.h	/^  int CMreset;$/;"	m	struct:progStatus
CoM	forces.c	/^void CoM(int i, COORD_TYPE* rxcm, COORD_TYPE* rycm, COORD_TYPE* rzcm)$/;"	f
CoMV	forces.c	/^void CoMV(int i, COORD_TYPE* vxcm, COORD_TYPE* vycm, COORD_TYPE* vzcm)$/;"	f
DECL_LIST	corutil.c	/^COORD_TYPE DECL_LIST;$/;"	v
DECL_LIST	nmpoly.h	/^COORD_TYPE DECL_LIST;$/;"	v
DECL_LIST	nmpoly.h	130;"	d
DQtens	nmpoly.h	/^COORD_TYPE Ptens[3], DQtens[3], C1c, C2c, C3c, C4c, velc, Gs[GSPOINT], $/;"	v
DQtensor	measures.c	/^void DQtensor(void)$/;"	f
DQxy	nmpoly.h	/^  COORD_TYPE DQxy;$/;"	m	struct:progStatus
DQyz	nmpoly.h	/^  COORD_TYPE DQyz;$/;"	m	struct:progStatus
DQzx	nmpoly.h	/^  COORD_TYPE DQzx;$/;"	m	struct:progStatus
DR_star	wtd.h	/^COORD_TYPE m0, m1, d, Vol, DR_star, Dphi_star;$/;"	v
DphiSq	nmpoly.h	/^  psi1c, psi2c, sqrtdr2, Aa, DrSqTot, DphiSq, GsAng[GSANGPOINT], Fs[FSPOINT],$/;"	v
Dphi_star	wtd.h	/^COORD_TYPE m0, m1, d, Vol, DR_star, Dphi_star;$/;"	v
Dphix	nmpoly.h	/^COORD_TYPE *Dphix, *Dphiy, *Dphiz;\/* Time integrals of angulars velocity$/;"	v
Dphiy	nmpoly.h	/^COORD_TYPE *Dphix, *Dphiy, *Dphiz;\/* Time integrals of angulars velocity$/;"	v
Dphiz	nmpoly.h	/^COORD_TYPE *Dphix, *Dphiy, *Dphiz;\/* Time integrals of angulars velocity$/;"	v
Dr	xvautil.h	/^COORD_TYPE *drSq, *dphiSq, *Dr, *Dt, *ddtdrSq, *ddtdphiSq, *Aalpha, *dr4,$/;"	v
DrFile	xvautil.h	/^  DrFile[128], vhFile[128], ddtdrFile[128], ddtdphiFile[128],$/;"	v
DrFlag	xvautil.h	/^  phiFlag=1, C4Flag=1, dphiSqFlag=1, drSqFlag=1, DtFlag=1, DrFlag=1, $/;"	v
DrSq	move.c	/^COORD_TYPE DrSq = 0.0, Mtot;$/;"	v
DrSqTot	nmpoly.h	/^  psi1c, psi2c, sqrtdr2, Aa, DrSqTot, DphiSq, GsAng[GSANGPOINT], Fs[FSPOINT],$/;"	v
Drot	nmpoly.h	/^COORD_TYPE Vc, V, E, Dtrans, temp, S[NUMK], dummy, eta, Drot, gr[MAXBIN], invs, press,$/;"	v
Dt	xvautil.h	/^COORD_TYPE *drSq, *dphiSq, *Dr, *Dt, *ddtdrSq, *ddtdphiSq, *Aalpha, *dr4,$/;"	v
DtAng	hetero.h	/^int greyLevel = 20, printEvery, tRun, DtTra, DtAng, DtTra_mean = 0, DtAng_mean = 0; $/;"	v
DtAng_mean	hetero.h	/^int greyLevel = 20, printEvery, tRun, DtTra, DtAng, DtTra_mean = 0, DtAng_mean = 0; $/;"	v
DtAng_mean	jumps.h	/^  DtTra_mean = 0, DtAng_mean = 0; $/;"	v
DtAng_mean	wtd.h	/^int printEvery, tRun, DtTra_star, DtAng_star, DtTra_mean = 0, DtAng_mean = 0; $/;"	v
DtAng_star	wtd.h	/^int printEvery, tRun, DtTra_star, DtAng_star, DtTra_mean = 0, DtAng_mean = 0; $/;"	v
DtFile	xvautil.h	/^  C3File[128], C4File[128], dphiSqFile[128], drSqFile[128], DtFile[128], $/;"	v
DtFlag	xvautil.h	/^  phiFlag=1, C4Flag=1, dphiSqFlag=1, drSqFlag=1, DtFlag=1, DrFlag=1, $/;"	v
DtTra	hetero.h	/^int greyLevel = 20, printEvery, tRun, DtTra, DtAng, DtTra_mean = 0, DtAng_mean = 0; $/;"	v
DtTra_mean	hetero.h	/^int greyLevel = 20, printEvery, tRun, DtTra, DtAng, DtTra_mean = 0, DtAng_mean = 0; $/;"	v
DtTra_mean	jumps.h	/^  DtTra_mean = 0, DtAng_mean = 0; $/;"	v
DtTra_mean	wtd.h	/^int printEvery, tRun, DtTra_star, DtAng_star, DtTra_mean = 0, DtAng_mean = 0; $/;"	v
DtTra_star	wtd.h	/^int printEvery, tRun, DtTra_star, DtAng_star, DtTra_mean = 0, DtAng_mean = 0; $/;"	v
Dtrans	nmpoly.h	/^COORD_TYPE Vc, V, E, Dtrans, temp, S[NUMK], dummy, eta, Drot, gr[MAXBIN], invs, press,$/;"	v
E	nmpoly.h	/^COORD_TYPE Vc, V, E, Dtrans, temp, S[NUMK], dummy, eta, Drot, gr[MAXBIN], invs, press,$/;"	v
EXT_DLST	corutil.c	/^COORD_TYPE EXT_DLST;$/;"	v
EXT_DLST	nmpoly.h	/^COORD_TYPE EXT_DLST;$/;"	v
EXT_DLST	nmpoly.h	141;"	d
EXT_DLST	nmpoly.h	142;"	d
EXT_SLST	nmpoly.h	86;"	d
EXT_SLST	nmpoly.h	87;"	d
Elrc	move.c	/^COORD_TYPE pi, s1t, Vol1t, L, invL, s1p, Elrc, Plrc;   $/;"	v
FCC	init.c	/^void FCC(int Nm, COORD_TYPE D, COORD_TYPE* m)$/;"	f
FSKMAX	nmpoly.h	64;"	d
FSPOINT	nmpoly.h	62;"	d
Fcoeff	init.c	/^double *Fcoeff[3]; $/;"	v
Fs	nmpoly.h	/^  psi1c, psi2c, sqrtdr2, Aa, DrSqTot, DphiSq, GsAng[GSANGPOINT], Fs[FSPOINT],$/;"	v
Fself	xvautil.h	/^  **Gself, **GsGsgauss, *Fself;$/;"	v
FselfFile	xvautil.h	/^  AalphaFile[128], GselfFile[128], GsGsgaussFile[128], FselfFile[128],$/;"	v
FselfFlag	xvautil.h	/^  GsGsgaussFlag = 1, FselfFlag = 1, wtdFlag = 1;$/;"	v
GSANGPOINT	nmpoly.h	60;"	d
GSPOINT	nmpoly.h	59;"	d
GSRMAX	nmpoly.h	58;"	d
Gs	nmpoly.h	/^COORD_TYPE Ptens[3], DQtens[3], C1c, C2c, C3c, C4c, velc, Gs[GSPOINT], $/;"	v
GsAng	nmpoly.h	/^  psi1c, psi2c, sqrtdr2, Aa, DrSqTot, DphiSq, GsAng[GSANGPOINT], Fs[FSPOINT],$/;"	v
GsGsg	nmpoly.h	/^  GsGsg[GSPOINT], temp_transl;$/;"	v
GsGsgauss	xvautil.h	/^  **Gself, **GsGsgauss, *Fself;$/;"	v
GsGsgaussFile	xvautil.h	/^  AalphaFile[128], GselfFile[128], GsGsgaussFile[128], FselfFile[128],$/;"	v
GsGsgaussFlag	xvautil.h	/^  GsGsgaussFlag = 1, FselfFlag = 1, wtdFlag = 1;$/;"	v
Gself	xvautil.h	/^  **Gself, **GsGsgauss, *Fself;$/;"	v
GselfFile	xvautil.h	/^  AalphaFile[128], GselfFile[128], GsGsgaussFile[128], FselfFile[128],$/;"	v
GselfFlag	xvautil.h	/^  ddtdrFlag = 1, ddtdphiFlag = 1, AalphaFlag = 1, GselfFlag = 1,$/;"	v
Gsnr	xvautil.h	/^int tCor, printEvery, nTeta, tBeg, Gsnr; $/;"	v
GsrMax	xvautil.h	/^COORD_TYPE m0, m1, d, Vol, GsrMax, wtdRmax, kMax;$/;"	v
HALFSQRT3	move.c	2065;"	d	file:
HNBOX	nmpoly.h	/^  int HNBOX;$/;"	m	struct:progStatus
HNBOX	nmpoly.h	690;"	d
HP	move.c	/^static double HP[6][2] = {{-0.5,HALFSQRT3},{0.5,HALFSQRT3},{1.0,0.0},$/;"	v	file:
K	move.c	/^COORD_TYPE W, K, WC, T1xx, T1yy, T1zz,$/;"	v
KBEG	nmpoly.h	686;"	d
KEND	nmpoly.h	687;"	d
L	move.c	/^COORD_TYPE pi, s1t, Vol1t, L, invL, s1p, Elrc, Plrc;   $/;"	v
LJForce	forces.c	/^void LJForce(int Nm, double rcut)$/;"	f
M	move.c	/^int NCell, mapSize, M;$/;"	v
M	nmpoly.h	/^  int M;                        \/* number of cells in each direction $/;"	m	struct:params
MAXBIN	nmpoly.h	55;"	d
MAXPAR	nmpoly.h	50;"	d
MB	nmpoly.h	/^int MB[NUMV];$/;"	v
MDSIMUL	nmpoly.h	11;"	d
MD_ALLOC_POLY	nmpoly.h	80;"	d
MD_HD_MIS	nmpoly.h	26;"	d
MD_HD_TMP	nmpoly.h	23;"	d
MD_HD_XVA	nmpoly.h	37;"	d
MD_HOME	nmpoly.h	15;"	d
MD_MESHDIR	nmpoly.h	20;"	d
MD_SIMDAT	nmpoly.h	17;"	d
MD_TAPE_MIS	nmpoly.h	33;"	d
MD_TAPE_TMP	nmpoly.h	29;"	d
MD_TAPE_XVA	nmpoly.h	38;"	d
MM	nmpoly.h	/^  int MM;$/;"	m	struct:params
MP	jumps.h	1;"	d
Mtot	hetero.h	/^COORD_TYPE Mtot, xvadt, dt, dteta, T; \/* T = temperature *\/$/;"	v
Mtot	jumps.h	/^COORD_TYPE m0, m1, d, Vol, Mtot;$/;"	v
Mtot	move.c	/^COORD_TYPE DrSq = 0.0, Mtot;$/;"	v
Mtot	wtd.h	/^COORD_TYPE Mtot, xvadt, dt, dteta, T; \/* T = temperature *\/$/;"	v
Mtot	xvautil.h	/^COORD_TYPE Mtot, xvadt, dt, dteta, T; \/* T = temperature *\/$/;"	v
N	nmpoly.h	/^  int N;$/;"	m	struct:measHead
N	nmpoly.h	/^  int N;$/;"	m	struct:xvaHead
NA	nmpoly.h	48;"	d
NCell	move.c	/^int NCell, mapSize, M;$/;"	v
NN	nmpoly.h	/^  int NN;         \/* Logatithmic block length *\/$/;"	m	struct:progStatus
NN	nmpoly.h	/^  int NN;$/;"	m	struct:params
NN	nmpoly.h	/^  int NN;$/;"	m	struct:xvaHead
NUMK	nmpoly.h	53;"	d
NUMK2AV	nmpoly.h	691;"	d
NUMV	nmpoly.h	57;"	d
NUM_MISURE	nmpoly.h	41;"	d
NUM_PAR	nmpoly.h	52;"	d
Nm	corutil.c	/^int SEGSIZE, corBool = 0, tBool = 0, ihdr = 1, ohdr = 1, posBool = 0, Nm,$/;"	v
Nm	hetero.h	/^int Nm; \/* Number of points for which calculate the time correlation$/;"	v
Nm	jumps.h	/^int Nm; \/* Number of points for which calculate the time correlation$/;"	v
Nm	wtd.h	/^int Nm; \/* Number of points for which calculate the time correlation$/;"	v
Nm	xvautil.h	/^int Nm; \/* Number of points for which calculate the time correlation$/;"	v
Nose	nmpoly.h	/^  int Nose; \/* if Nose=1 use Nose method, otherwise not *\/$/;"	m	struct:progStatus
OP	nmpoly.h	549;"	d
OS	nmpoly.h	548;"	d
OconvStruct	nmpoly.h	/^struct convStruct OconvStruct[]=$/;"	v
OmeasHead	nmpoly.h	/^struct measHead OmeasHead[NUM_MISURE];$/;"	v
Omeasure	nmpoly.h	/^struct measure Omeasure[NUM_MISURE]=$/;"	v
Oparams	nmpoly.h	/^struct params Oparams;$/;"	v
OprogStatus	nmpoly.h	/^struct progStatus OprogStatus;$/;"	v
OsinglePar	nmpoly.h	/^struct singlePar OsinglePar[] = { $/;"	v
OxvaH	hetero.c	/^struct xvaHead OxvaH; \/* measure file header (see mdsimul.h)*\/$/;"	v
OxvaH	jumps.c	/^struct xvaHead OxvaH; \/* measure file header (see mdsimul.h)*\/$/;"	v
OxvaH	wtd.c	/^struct xvaHead OxvaH; \/* measure file header (see mdsimul.h)*\/$/;"	v
OxvaH	xvautil.c	/^struct xvaHead OxvaH; \/* measure file header (see mdsimul.h)*\/$/;"	v
OxvaHead	nmpoly.h	/^struct xvaHead OxvaHead;$/;"	v
OxvaPar	hetero.h	/^struct singlePar OxvaPar[] = { $/;"	v
OxvaPar	jumps.h	/^struct singlePar OxvaPar[] = { $/;"	v
OxvaPar	wtd.h	/^struct singlePar OxvaPar[] = { $/;"	v
OxvaPar	xvautil.h	/^struct singlePar OxvaPar[] = { $/;"	v
P	nmpoly.h	/^  COORD_TYPE P;			\/* pressure *\/$/;"	m	struct:params
Patxx	move.c	/^  Patxy, Patyz, Patzx, Patxx, Patyy, Patzz,$/;"	v
Patxy	move.c	/^  Patxy, Patyz, Patzx, Patxx, Patyy, Patzz,$/;"	v
Patyy	move.c	/^  Patxy, Patyz, Patzx, Patxx, Patyy, Patzz,$/;"	v
Patyz	move.c	/^  Patxy, Patyz, Patzx, Patxx, Patyy, Patzz,$/;"	v
Patzx	move.c	/^  Patxy, Patyz, Patzx, Patxx, Patyy, Patzz,$/;"	v
Patzz	move.c	/^  Patxy, Patyz, Patzx, Patxx, Patyy, Patzz,$/;"	v
Plrc	move.c	/^COORD_TYPE pi, s1t, Vol1t, L, invL, s1p, Elrc, Plrc;   $/;"	v
Pmxx	move.c	/^  Wmxy, Wmyz, Wmzx, Pmxx, Pmyy, Pmzz, Pmxy, Pmyz, Pmzx, T1mxy, $/;"	v
Pmxy	move.c	/^  Wmxy, Wmyz, Wmzx, Pmxx, Pmyy, Pmzz, Pmxy, Pmyz, Pmzx, T1mxy, $/;"	v
Pmyy	move.c	/^  Wmxy, Wmyz, Wmzx, Pmxx, Pmyy, Pmzz, Pmxy, Pmyz, Pmzx, T1mxy, $/;"	v
Pmyz	move.c	/^  Wmxy, Wmyz, Wmzx, Pmxx, Pmyy, Pmzz, Pmxy, Pmyz, Pmzx, T1mxy, $/;"	v
Pmzx	move.c	/^  Wmxy, Wmyz, Wmzx, Pmxx, Pmyy, Pmzz, Pmxy, Pmyz, Pmzx, T1mxy, $/;"	v
Pmzz	move.c	/^  Wmxy, Wmyz, Wmzx, Pmxx, Pmyy, Pmzz, Pmxy, Pmyz, Pmzx, T1mxy, $/;"	v
Ptens	nmpoly.h	/^COORD_TYPE Ptens[3], DQtens[3], C1c, C2c, C3c, C4c, velc, Gs[GSPOINT], $/;"	v
Ptensor	measures.c	/^void Ptensor(void)$/;"	f
Pxx	move.c	/^  Wxy, Wyz, Wzx, Pxx, Pyy, Pzz, Pxy, Pyz, Pzx, Wm, Wmxx, Wmyy, Wmzz, $/;"	v
Pxy	move.c	/^  Wxy, Wyz, Wzx, Pxx, Pyy, Pzz, Pxy, Pyz, Pzx, Wm, Wmxx, Wmyy, Wmzz, $/;"	v
PxyArr	nmpoly.h	/^  COORD_TYPE PxyArr[5];$/;"	m	struct:progStatus
Pyy	move.c	/^  Wxy, Wyz, Wzx, Pxx, Pyy, Pzz, Pxy, Pyz, Pzx, Wm, Wmxx, Wmyy, Wmzz, $/;"	v
Pyz	move.c	/^  Wxy, Wyz, Wzx, Pxx, Pyy, Pzz, Pxy, Pyz, Pzx, Wm, Wmxx, Wmyy, Wmzz, $/;"	v
PyzArr	nmpoly.h	/^  COORD_TYPE PyzArr[5];$/;"	m	struct:progStatus
Pzx	move.c	/^  Wxy, Wyz, Wzx, Pxx, Pyy, Pzz, Pxy, Pyz, Pzx, Wm, Wmxx, Wmyy, Wmzz, $/;"	v
PzxArr	nmpoly.h	/^  COORD_TYPE PzxArr[5];$/;"	m	struct:progStatus
Pzz	move.c	/^  Wxy, Wyz, Wzx, Pxx, Pyy, Pzz, Pxy, Pyz, Pzx, Wm, Wmxx, Wmyy, Wmzz, $/;"	v
Q	nmpoly.h	/^  COORD_TYPE Q;$/;"	m	struct:progStatus
RADFACT	hetero.h	/^COORD_TYPE RADFACT = 4.0, *rCMt0x, *rCMt0y,$/;"	v
RBEG	nmpoly.h	688;"	d
REND	nmpoly.h	689;"	d
Rand3	init.c	/^void Rand3(double *ex, double *ey, double *ez)$/;"	f
Rmx	move.c	/^COORD_TYPE  *Rmx, *Rmy, *Rmz;$/;"	v
Rmy	move.c	/^COORD_TYPE  *Rmx, *Rmy, *Rmz;$/;"	v
Rmz	move.c	/^COORD_TYPE  *Rmx, *Rmy, *Rmz;$/;"	v
S	nmpoly.h	/^COORD_TYPE Vc, V, E, Dtrans, temp, S[NUMK], dummy, eta, Drot, gr[MAXBIN], invs, press,$/;"	v
SAVE_LIST	nmpoly.h	81;"	d
SEGSIZE	corutil.c	/^int SEGSIZE, corBool = 0, tBool = 0, ihdr = 1, ohdr = 1, posBool = 0, Nm,$/;"	v
SIMUL	forces.c	2;"	d	file:
SIMUL	init.c	2;"	d	file:
SIMUL	measures.c	2;"	d	file:
SIMUL	move.c	2;"	d	file:
SkCM	measures.c	/^void SkCM(void)$/;"	f
T	corutil.c	/^COORD_TYPE T;$/;"	v
T	hetero.h	/^COORD_TYPE Mtot, xvadt, dt, dteta, T; \/* T = temperature *\/$/;"	v
T	nmpoly.h	/^  COORD_TYPE T;			\/* temperature *\/$/;"	m	struct:params
T	nmpoly.h	/^  double T;$/;"	m	struct:measHead
T	nmpoly.h	/^  double T;$/;"	m	struct:xvaHead
T	wtd.h	/^COORD_TYPE Mtot, xvadt, dt, dteta, T; \/* T = temperature *\/$/;"	v
T	xvautil.h	/^COORD_TYPE Mtot, xvadt, dt, dteta, T; \/* T = temperature *\/$/;"	v
T1mxx	move.c	/^  T1myz, T1mzx, T1mxx, T1myy, T1mzz;  $/;"	v
T1mxy	move.c	/^  Wmxy, Wmyz, Wmzx, Pmxx, Pmyy, Pmzz, Pmxy, Pmyz, Pmzx, T1mxy, $/;"	v
T1myy	move.c	/^  T1myz, T1mzx, T1mxx, T1myy, T1mzz;  $/;"	v
T1myz	move.c	/^  T1myz, T1mzx, T1mxx, T1myy, T1mzz;  $/;"	v
T1mzx	move.c	/^  T1myz, T1mzx, T1mxx, T1myy, T1mzz;  $/;"	v
T1mzz	move.c	/^  T1myz, T1mzx, T1mxx, T1myy, T1mzz;  $/;"	v
T1xx	move.c	/^  T1xx, T1yy, T1zz, T1xy, T1yz, T1zx, WCxy, WCyz, WCzx, $/;"	v
T1xx	move.c	/^COORD_TYPE W, K, WC, T1xx, T1yy, T1zz,$/;"	v
T1xy	move.c	/^  T1xx, T1yy, T1zz, T1xy, T1yz, T1zx, WCxy, WCyz, WCzx, $/;"	v
T1yy	move.c	/^  T1xx, T1yy, T1zz, T1xy, T1yz, T1zx, WCxy, WCyz, WCzx, $/;"	v
T1yy	move.c	/^COORD_TYPE W, K, WC, T1xx, T1yy, T1zz,$/;"	v
T1yz	move.c	/^  T1xx, T1yy, T1zz, T1xy, T1yz, T1zx, WCxy, WCyz, WCzx, $/;"	v
T1zx	move.c	/^  T1xx, T1yy, T1zz, T1xy, T1yz, T1zx, WCxy, WCyz, WCzx, $/;"	v
T1zz	move.c	/^  T1xx, T1yy, T1zz, T1xy, T1yz, T1zx, WCxy, WCyz, WCzx, $/;"	v
T1zz	move.c	/^COORD_TYPE W, K, WC, T1xx, T1yy, T1zz,$/;"	v
TINY	move.c	1750;"	d	file:
TXT	measures.c	/^char TXT[MSG_LEN], TXTA[10][MSG_LEN];$/;"	v
TXTA	measures.c	/^char TXT[MSG_LEN], TXTA[10][MSG_LEN];$/;"	v
V	nmpoly.h	/^COORD_TYPE Vc, V, E, Dtrans, temp, S[NUMK], dummy, eta, Drot, gr[MAXBIN], invs, press,$/;"	v
VBEG	nmpoly.h	684;"	d
VEND	nmpoly.h	685;"	d
Vc	nmpoly.h	/^COORD_TYPE Vc, V, E, Dtrans, temp, S[NUMK], dummy, eta, Drot, gr[MAXBIN], invs, press,$/;"	v
Vol	hetero.h	/^COORD_TYPE m0, m1, d, Vol, mobTraPerc, mobAngPerc;$/;"	v
Vol	jumps.h	/^COORD_TYPE m0, m1, d, Vol, Mtot;$/;"	v
Vol	nmpoly.h	/^  double Vol;$/;"	m	struct:measHead
Vol	nmpoly.h	/^  double Vol;$/;"	m	struct:xvaHead
Vol	wtd.h	/^COORD_TYPE m0, m1, d, Vol, DR_star, Dphi_star;$/;"	v
Vol	xvautil.h	/^COORD_TYPE m0, m1, d, Vol, GsrMax, wtdRmax, kMax;$/;"	v
Vol1t	move.c	/^COORD_TYPE pi, s1t, Vol1t, L, invL, s1p, Elrc, Plrc;   $/;"	v
W	move.c	/^COORD_TYPE W, K, WC, T1xx, T1yy, T1zz,$/;"	v
W	nmpoly.h	/^  COORD_TYPE W;$/;"	m	struct:progStatus
WC	move.c	/^COORD_TYPE W, K, WC, T1xx, T1yy, T1zz,$/;"	v
WCxx	move.c	/^  WCxx, WCyy, WCzz, Wxx, Wyy, Wzz,$/;"	v
WCxy	move.c	/^  T1xx, T1yy, T1zz, T1xy, T1yz, T1zx, WCxy, WCyz, WCzx, $/;"	v
WCyy	move.c	/^  WCxx, WCyy, WCzz, Wxx, Wyy, Wzz,$/;"	v
WCyz	move.c	/^  T1xx, T1yy, T1zz, T1xy, T1yz, T1zx, WCxy, WCyz, WCzx, $/;"	v
WCzx	move.c	/^  T1xx, T1yy, T1zz, T1xy, T1yz, T1zx, WCxy, WCyz, WCzx, $/;"	v
WCzz	move.c	/^  WCxx, WCyy, WCzz, Wxx, Wyy, Wzz,$/;"	v
Wm	move.c	/^  Wxy, Wyz, Wzx, Pxx, Pyy, Pzz, Pxy, Pyz, Pzx, Wm, Wmxx, Wmyy, Wmzz, $/;"	v
Wmxx	move.c	/^  Wxy, Wyz, Wzx, Pxx, Pyy, Pzz, Pxy, Pyz, Pzx, Wm, Wmxx, Wmyy, Wmzz, $/;"	v
Wmxy	move.c	/^  Wmxy, Wmyz, Wmzx, Pmxx, Pmyy, Pmzz, Pmxy, Pmyz, Pmzx, T1mxy, $/;"	v
Wmyy	move.c	/^  Wxy, Wyz, Wzx, Pxx, Pyy, Pzz, Pxy, Pyz, Pzx, Wm, Wmxx, Wmyy, Wmzz, $/;"	v
Wmyz	move.c	/^  Wmxy, Wmyz, Wmzx, Pmxx, Pmyy, Pmzz, Pmxy, Pmyz, Pmzx, T1mxy, $/;"	v
Wmzx	move.c	/^  Wmxy, Wmyz, Wmzx, Pmxx, Pmyy, Pmzz, Pmxy, Pmyz, Pmzx, T1mxy, $/;"	v
Wmzz	move.c	/^  Wxy, Wyz, Wzx, Pxx, Pyy, Pzz, Pxy, Pyz, Pzx, Wm, Wmxx, Wmyy, Wmzz, $/;"	v
Wxx	move.c	/^  WCxx, WCyy, WCzz, Wxx, Wyy, Wzz,$/;"	v
Wxy	move.c	/^  Wxy, Wyz, Wzx, Pxx, Pyy, Pzz, Pxy, Pyz, Pzx, Wm, Wmxx, Wmyy, Wmzz, $/;"	v
Wyy	move.c	/^  WCxx, WCyy, WCzz, Wxx, Wyy, Wzz,$/;"	v
Wyz	move.c	/^  Wxy, Wyz, Wzx, Pxx, Pyy, Pzz, Pxy, Pyz, Pzx, Wm, Wmxx, Wmyy, Wmzz, $/;"	v
Wzx	move.c	/^  Wxy, Wyz, Wzx, Pxx, Pyy, Pzz, Pxy, Pyz, Pzx, Wm, Wmxx, Wmyy, Wmzz, $/;"	v
Wzz	move.c	/^  WCxx, WCyy, WCzz, Wxx, Wyy, Wzz,$/;"	v
XTERM	nmpoly.h	14;"	d
XVA_ALST	nmpoly.h	96;"	d
XVA_DLST	hetero.c	/^COORD_TYPE XVA_DLST;$/;"	v
XVA_DLST	jumps.c	/^COORD_TYPE XVA_DLST;$/;"	v
XVA_DLST	nmpoly.h	99;"	d
XVA_DLST	wtd.c	/^COORD_TYPE XVA_DLST;$/;"	v
XVA_DLST	xvautil.c	/^COORD_TYPE XVA_DLST;$/;"	v
XVA_LIST	nmpoly.h	91;"	d
XVA_NUM	nmpoly.h	94;"	d
aclose	hetero.c	/^void aclose(FILE* ofs)$/;"	f
aclose	jumps.c	/^void aclose(FILE* ofs)$/;"	f
aclose	wtd.c	/^void aclose(FILE* ofs)$/;"	f
aclose	xvautil.c	/^void aclose(FILE* ofs)$/;"	f
angvel	init.c	/^void angvel (int Nm, COORD_TYPE temp, COORD_TYPE m[NA], COORD_TYPE d)$/;"	f
aopen	hetero.c	/^FILE* aopen(char *fileName)$/;"	f
aopen	jumps.c	/^FILE* aopen(char *fileName)$/;"	f
aopen	wtd.c	/^FILE* aopen(char *fileName)$/;"	f
aopen	xvautil.c	/^FILE* aopen(char *fileName)$/;"	f
args	hetero.c	/^void args(int argc,char **argv)$/;"	f
args	jumps.c	/^void args(int argc,char **argv)$/;"	f
args	wtd.c	/^void args(int argc,char **argv)$/;"	f
args	xvautil.c	/^void args(int argc,char **argv)$/;"	f
avVol	nmpoly.h	/^  COORD_TYPE avVol;$/;"	m	struct:progStatus
avVol1	nmpoly.h	/^  COORD_TYPE avVol1;$/;"	m	struct:progStatus
avngEta	nmpoly.h	/^  int avngEta;$/;"	m	struct:progStatus
avngMB	nmpoly.h	/^  int avngMB;$/;"	m	struct:progStatus
avngPress	nmpoly.h	/^  int avngPress;$/;"	m	struct:progStatus
avngS	nmpoly.h	/^  int avngS;$/;"	m	struct:progStatus
avngTemp	nmpoly.h	/^  int avngTemp;$/;"	m	struct:progStatus
avnggr	nmpoly.h	/^  int avnggr;$/;"	m	struct:progStatus
avs	nmpoly.h	/^  COORD_TYPE avs;$/;"	m	struct:progStatus
bakSaveMode	nmpoly.h	/^  int bakSaveMode;\/* save mode for ascii backup *\/$/;"	m	struct:progStatus
bakSteps	nmpoly.h	/^  int bakSteps;    \/* steps between two savings of restore files on HD*\/$/;"	m	struct:progStatus
bakStepsAscii	nmpoly.h	/^  int bakStepsAscii;$/;"	m	struct:progStatus
base	nmpoly.h	/^  double base;    \/* We save at base^^NN step *\/$/;"	m	struct:progStatus
base	nmpoly.h	/^  double base;$/;"	m	struct:xvaHead
baseGrey	hetero.h	/^int baseGrey = 20, maxGrey = 225;$/;"	v
bc1	move.c	/^const COORD_TYPE bc1 = 14.0\/45.0, bc2 = 64.0\/45.0, bc3 = 24.0\/45.0;$/;"	v
bc2	move.c	/^const COORD_TYPE bc1 = 14.0\/45.0, bc2 = 64.0\/45.0, bc3 = 24.0\/45.0;$/;"	v
bc3	move.c	/^const COORD_TYPE bc1 = 14.0\/45.0, bc2 = 64.0\/45.0, bc3 = 24.0\/45.0;$/;"	v
bigauss	init.c	/^void bigauss(double sigma1, double sigma2, double c12, double* chsi1p, double* chsi2p)$/;"	f
boxcmBool	corutil.c	/^  boxcmBool = 0;$/;"	v
buildhexagon	move.c	/^void buildhexagon(double diam, int n, double *rx, double *ry, int *np)$/;"	f
calcAngVel	hetero.c	/^void calcAngVel(COORD_TYPE* ox, COORD_TYPE* oy, COORD_TYPE *oz)$/;"	f
calcAngVel	wtd.c	/^void calcAngVel(COORD_TYPE* ox, COORD_TYPE* oy, COORD_TYPE *oz)$/;"	f
calcAngVel	xvautil.c	/^void calcAngVel(COORD_TYPE* ox, COORD_TYPE* oy, COORD_TYPE *oz)$/;"	f
calcCM	hetero.c	/^void calcCM(COORD_TYPE* rCMx, COORD_TYPE* rCMy, COORD_TYPE* rCMz)$/;"	f
calcCM	wtd.c	/^void calcCM(COORD_TYPE* rCMx, COORD_TYPE* rCMy, COORD_TYPE* rCMz)$/;"	f
calcCM	xvautil.c	/^void calcCM(COORD_TYPE* rCMx, COORD_TYPE* rCMy, COORD_TYPE* rCMz)$/;"	f
calcCMVel	hetero.c	/^void calcCMVel(COORD_TYPE *vxCM, COORD_TYPE *vyCM, COORD_TYPE *vzCM)$/;"	f
calcCMVel	wtd.c	/^void calcCMVel(COORD_TYPE *vxCM, COORD_TYPE *vyCM, COORD_TYPE *vzCM)$/;"	f
calcCMVel	xvautil.c	/^void calcCMVel(COORD_TYPE *vxCM, COORD_TYPE *vyCM, COORD_TYPE *vzCM)$/;"	f
calcCMi	hetero.c	/^void calcCMi(int i, COORD_TYPE *Rx, COORD_TYPE *Ry, COORD_TYPE *Rz)$/;"	f
calcCMi	jumps.c	/^void calcCMi(int ii, COORD_TYPE* rCMx, COORD_TYPE* rCMy, COORD_TYPE* rCMz)$/;"	f
calcCMi	wtd.c	/^void calcCMi(int i, COORD_TYPE *Rx, COORD_TYPE *Ry, COORD_TYPE *Rz)$/;"	f
calcOrientVect	hetero.c	/^void calcOrientVect(COORD_TYPE* u01x, COORD_TYPE* u01y, COORD_TYPE *u01z)$/;"	f
calcOrientVect	wtd.c	/^void calcOrientVect(COORD_TYPE* u01x, COORD_TYPE* u01y, COORD_TYPE *u01z)$/;"	f
calcOrientVect	xvautil.c	/^void calcOrientVect(COORD_TYPE* u01x, COORD_TYPE* u01y, COORD_TYPE *u01z)$/;"	f
calcOrientVecti	jumps.c	/^void calcOrientVecti(int ii, $/;"	f
calcPtensAt	move.c	/^void calcPtensAt(int Nm, COORD_TYPE VOL1)$/;"	f
calcPtensMol	move.c	/^void calcPtensMol(int Nm, COORD_TYPE VOL1)$/;"	f
calcT1diagAt	move.c	/^COORD_TYPE  calcT1diagAt(int Nm, COORD_TYPE VOL1)$/;"	f
calcT1diagMol	move.c	/^COORD_TYPE  calcT1diagMol(int Nm, COORD_TYPE VOL1)$/;"	f
checkNebrRebuild	forces.c	/^void checkNebrRebuild(void)$/;"	f
check_distances	init.c	/^void check_distances(char* str)$/;"	f
check_sigmas	init.c	/^int check_sigmas(void)$/;"	f
checkdist	init.c	/^int checkdist(int ir, int ar)$/;"	f
checkdists	move.c	/^void checkdists(char *str)$/;"	f
chkeqstps	nmpoly.h	/^  int chkeqstps; \/* ogni chkeqstps controlla se il sistema è equilibrato *\/$/;"	m	struct:progStatus
chks	move.c	/^void chks(void)$/;"	f
chksVol	move.c	/^void chksVol(void)$/;"	f
closeMeasFile	hetero.c	/^void closeMeasFile(int fd)$/;"	f
closeMeasFile	wtd.c	/^void closeMeasFile(int fd)$/;"	f
closeMeasFile	xvautil.c	/^void closeMeasFile(int fd)$/;"	f
comvel	init.c	/^void comvel (int Nm, COORD_TYPE temp, COORD_TYPE m[NA])$/;"	f
corBool	corutil.c	/^int SEGSIZE, corBool = 0, tBool = 0, ihdr = 1, ohdr = 1, posBool = 0, Nm,$/;"	v
curStep	nmpoly.h	/^  int curStep;	\/* current step of simulation *\/$/;"	m	struct:params
d	hetero.h	/^COORD_TYPE m0, m1, d, Vol, mobTraPerc, mobAngPerc;$/;"	v
d	jumps.h	/^COORD_TYPE m0, m1, d, Vol, Mtot;$/;"	v
d	nmpoly.h	/^  COORD_TYPE d;                 \/* distance between atoms *\/$/;"	m	struct:params
d	wtd.h	/^COORD_TYPE m0, m1, d, Vol, DR_star, Dphi_star;$/;"	v
d	xvautil.h	/^COORD_TYPE m0, m1, d, Vol, GsrMax, wtdRmax, kMax;$/;"	v
dataFiles	nmpoly.h	/^  char dataFiles[NUM_MISURE][NAME_LENGTH];$/;"	m	struct:progStatus
ddtdphiFile	xvautil.h	/^  DrFile[128], vhFile[128], ddtdrFile[128], ddtdphiFile[128],$/;"	v
ddtdphiFlag	xvautil.h	/^  ddtdrFlag = 1, ddtdphiFlag = 1, AalphaFlag = 1, GselfFlag = 1,$/;"	v
ddtdphiSq	xvautil.h	/^COORD_TYPE *drSq, *dphiSq, *Dr, *Dt, *ddtdrSq, *ddtdphiSq, *Aalpha, *dr4,$/;"	v
ddtdrFile	xvautil.h	/^  DrFile[128], vhFile[128], ddtdrFile[128], ddtdphiFile[128],$/;"	v
ddtdrFlag	xvautil.h	/^  ddtdrFlag = 1, ddtdphiFlag = 1, AalphaFlag = 1, GselfFlag = 1,$/;"	v
ddtdrSq	xvautil.h	/^COORD_TYPE *drSq, *dphiSq, *Dr, *Dt, *ddtdrSq, *ddtdphiSq, *Aalpha, *dr4,$/;"	v
defaults	hetero.c	/^void defaults(void)$/;"	f
defaults	jumps.c	/^void defaults(void)$/;"	f
defaults	wtd.c	/^void defaults(void)$/;"	f
defaults	xvautil.c	/^void defaults(void)$/;"	f
dispHi	move.c	/^COORD_TYPE dispHi;$/;"	v
dphiSq	xvautil.h	/^COORD_TYPE *drSq, *dphiSq, *Dr, *Dt, *ddtdrSq, *ddtdphiSq, *Aalpha, *dr4,$/;"	v
dphiSqFile	xvautil.h	/^  C3File[128], C4File[128], dphiSqFile[128], drSqFile[128], DtFile[128], $/;"	v
dphiSqFlag	xvautil.h	/^  phiFlag=1, C4Flag=1, dphiSqFlag=1, drSqFlag=1, DtFlag=1, DrFlag=1, $/;"	v
dr4	xvautil.h	/^COORD_TYPE *drSq, *dphiSq, *Dr, *Dt, *ddtdrSq, *ddtdphiSq, *Aalpha, *dr4,$/;"	v
drSq	xvautil.h	/^COORD_TYPE *drSq, *dphiSq, *Dr, *Dt, *ddtdrSq, *ddtdphiSq, *Aalpha, *dr4,$/;"	v
drSqFile	xvautil.h	/^  C3File[128], C4File[128], dphiSqFile[128], drSqFile[128], DtFile[128], $/;"	v
drSqFlag	xvautil.h	/^  phiFlag=1, C4Flag=1, dphiSqFlag=1, drSqFlag=1, DtFlag=1, DrFlag=1, $/;"	v
dt	hetero.h	/^COORD_TYPE Mtot, xvadt, dt, dteta, T; \/* T = temperature *\/$/;"	v
dt	jumps.h	/^COORD_TYPE xvadt, dt;$/;"	v
dt	nmpoly.h	/^  double dt;     \/* dt of each steps *\/$/;"	m	struct:xvaHead
dt	nmpoly.h	/^  double dt;$/;"	m	struct:measHead
dt	wtd.h	/^COORD_TYPE Mtot, xvadt, dt, dteta, T; \/* T = temperature *\/$/;"	v
dt	xvautil.h	/^COORD_TYPE Mtot, xvadt, dt, dteta, T; \/* T = temperature *\/$/;"	v
dteta	hetero.h	/^COORD_TYPE Mtot, xvadt, dt, dteta, T; \/* T = temperature *\/$/;"	v
dteta	wtd.h	/^COORD_TYPE Mtot, xvadt, dt, dteta, T; \/* T = temperature *\/$/;"	v
dteta	xvautil.h	/^COORD_TYPE Mtot, xvadt, dt, dteta, T; \/* T = temperature *\/$/;"	v
dummy	nmpoly.h	/^COORD_TYPE Vc, V, E, Dtrans, temp, S[NUMK], dummy, eta, Drot, gr[MAXBIN], invs, press,$/;"	v
endFormat	nmpoly.h	/^  int endFormat; \/* 0 = binary 1 = ascii 2 = both *\/$/;"	m	struct:progStatus
endfile	nmpoly.h	/^  char endfile[NAME_LENGTH];$/;"	m	struct:progStatus
energy	measures.c	/^void energy(void)$/;"	f
epsilon	nmpoly.h	/^  double epsilon;               \/* dieletric constant *\/$/;"	m	struct:params
equilibrat	nmpoly.h	/^  int equilibrat;               \/* != 0 if equilibrating *\/$/;"	m	struct:params
equilibrated	nmpoly.h	/^  int equilibrated; \/* 1 = system equilibrated *\/$/;"	m	struct:progStatus
eta	nmpoly.h	/^COORD_TYPE Vc, V, E, Dtrans, temp, S[NUMK], dummy, eta, Drot, gr[MAXBIN], invs, press,$/;"	v
fstps	nmpoly.h	/^  double fstps;         \/* There are KK block each base^NN long *\/$/;"	m	struct:progStatus
gauss	init.c	/^COORD_TYPE gauss(void)$/;"	f
getMeanAngPos	hetero.c	/^void getMeanAngPos(int mfd, int Nm, int t_cur, $/;"	f
getMeanAngPos	jumps.c	/^void getMeanAngPos(int mfd, int Np, int t_cur,  $/;"	f
getMeanAngPos	wtd.c	/^void getMeanAngPos(int mfd, int Nm, int t_cur, $/;"	f
getMeanPosition	hetero.c	/^void getMeanPosition(int mfd, int Nm, int t_cur, $/;"	f
getMeanPosition	wtd.c	/^void getMeanPosition(int mfd, int Nm, int t_cur, $/;"	f
getMeanPositions	jumps.c	/^void getMeanPositions(int mfd, int Np, int t_cur,  $/;"	f
getPhi	xvautil.c	/^void getPhi(COORD_TYPE* fix, COORD_TYPE* fiy, COORD_TYPE* fiz)$/;"	f
getPhii	hetero.c	/^void getPhii(int i, COORD_TYPE* fix, COORD_TYPE* fiy, COORD_TYPE* fiz)$/;"	f
getPhii	wtd.c	/^void getPhii(int i, COORD_TYPE* fix, COORD_TYPE* fiy, COORD_TYPE* fiz)$/;"	f
gr	nmpoly.h	/^COORD_TYPE Vc, V, E, Dtrans, temp, S[NUMK], dummy, eta, Drot, gr[MAXBIN], invs, press,$/;"	v
gr23	nmpoly.h	/^  gr23[MAXBIN], gr33[MAXBIN], press_m, press_at;$/;"	v
gr33	nmpoly.h	/^  gr23[MAXBIN], gr33[MAXBIN], press_m, press_at;$/;"	v
greyLevel	hetero.h	/^int greyLevel = 20, printEvery, tRun, DtTra, DtAng, DtTra_mean = 0, DtAng_mean = 0; $/;"	v
grow	nmpoly.h	/^  int grow;$/;"	m	struct:progStatus
head	move.c	/^int *head, *list, *map;  \/* arrays of integer *\/$/;"	v
heteroAngFile	hetero.h	/^char heteroAngFile[128], heteroTraFile[128];$/;"	v
heteroAngFlag	hetero.h	/^int heteroTraFlag = 1, heteroAngFlag = 1, mathFlag = 0;$/;"	v
heteroTraFile	hetero.h	/^char heteroAngFile[128], heteroTraFile[128];$/;"	v
heteroTraFlag	hetero.h	/^int heteroTraFlag = 1, heteroAngFlag = 1, mathFlag = 0;$/;"	v
hist	nmpoly.h	/^  int hist[MAXBIN];$/;"	m	struct:progStatus
histMB	nmpoly.h	/^  int histMB[NUMV];$/;"	m	struct:progStatus
iCell	forces.c	/^int iCell(int ix, int iy, int iz) $/;"	f
ihdr	corutil.c	/^int SEGSIZE, corBool = 0, tBool = 0, ihdr = 1, ohdr = 1, posBool = 0, Nm,$/;"	v
info	corutil.c	/^void info(void)$/;"	f
infoBool	corutil.c	/^int infoBool = 0;$/;"	v
inifile	nmpoly.h	/^  char inifile[NAME_LENGTH];$/;"	m	struct:progStatus
initCalc	nmpoly.h	/^  int initCalc[NUM_MISURE];$/;"	m	struct:progStatus
initCoord	init.c	/^void initCoord(void)$/;"	f
initStep	nmpoly.h	/^  int initStep[NUM_MISURE]; $/;"	m	struct:progStatus
inputFile	corutil.c	/^char inputFile[NAME_LENGTH];\/* input file (measures file) *\/$/;"	v
inputFile	hetero.h	/^char inputFile[NAME_LENGTH], xvaparsFile[NAME_LENGTH];$/;"	v
inputFile	jumps.h	/^char inputFile[NAME_LENGTH], xvaparsFile[NAME_LENGTH], sqrtdr2File[255], $/;"	v
inputFile	wtd.h	/^char inputFile[NAME_LENGTH], xvaparsFile[NAME_LENGTH];$/;"	v
inputFile	xvautil.h	/^char inputFile[NAME_LENGTH], xvaparsFile[NAME_LENGTH];$/;"	v
inv4pieps0	forces.c	/^const double inv4pieps0=1.43999;$/;"	v
invL	move.c	/^COORD_TYPE pi, s1t, Vol1t, L, invL, s1p, Elrc, Plrc;   $/;"	v
invalArg	hetero.c	/^void invalArg(void)$/;"	f
invalArg	jumps.c	/^void invalArg(void)$/;"	f
invalArg	wtd.c	/^void invalArg(void)$/;"	f
invalArg	xvautil.c	/^void invalArg(void)$/;"	f
invs	nmpoly.h	/^COORD_TYPE Vc, V, E, Dtrans, temp, S[NUMK], dummy, eta, Drot, gr[MAXBIN], invs, press,$/;"	v
ipart	nmpoly.h	/^  int ipart;            \/* Particle to follow in its motion inside the box *\/$/;"	m	struct:progStatus
ittol	move.c	/^const double ittol = 1E-20;$/;"	v
kMax	xvautil.h	/^COORD_TYPE m0, m1, d, Vol, GsrMax, wtdRmax, kMax;$/;"	v
kinet	forces.c	/^void kinet(int Nm, COORD_TYPE** velx, COORD_TYPE** vely, COORD_TYPE** velz,$/;"	f
lastJump	hetero.h	/^int* lastJump;$/;"	v
lastJump	wtd.h	/^int* lastJump;$/;"	v
links	forces.c	/^void  links(int Nm, COORD_TYPE rcut)$/;"	f
list	move.c	/^int *head, *list, *map;  \/* arrays of integer *\/$/;"	v
lubksb	move.c	/^void lubksb(double a[3][3], int* indx, double* b)$/;"	f
ludcmp	move.c	/^void ludcmp(double a[3][3], int* indx, double* d)$/;"	f
m	nmpoly.h	/^  COORD_TYPE m[NA];                 \/* atom mass *\/$/;"	m	struct:params
m0	hetero.h	/^COORD_TYPE m0, m1, d, Vol, mobTraPerc, mobAngPerc;$/;"	v
m0	jumps.h	/^COORD_TYPE m0, m1, d, Vol, Mtot;$/;"	v
m0	wtd.h	/^COORD_TYPE m0, m1, d, Vol, DR_star, Dphi_star;$/;"	v
m0	xvautil.h	/^COORD_TYPE m0, m1, d, Vol, GsrMax, wtdRmax, kMax;$/;"	v
m1	hetero.h	/^COORD_TYPE m0, m1, d, Vol, mobTraPerc, mobAngPerc;$/;"	v
m1	jumps.h	/^COORD_TYPE m0, m1, d, Vol, Mtot;$/;"	v
m1	wtd.h	/^COORD_TYPE m0, m1, d, Vol, DR_star, Dphi_star;$/;"	v
m1	xvautil.h	/^COORD_TYPE m0, m1, d, Vol, GsrMax, wtdRmax, kMax;$/;"	v
main	corutil.c	/^void main(int argc, char* argv[])$/;"	f
main	hetero.c	/^void main(int argc, char** argv)$/;"	f
main	jumps.c	/^void main(int argc, char* argv[])$/;"	f
main	wtd.c	/^void main(int argc, char** argv)$/;"	f
main	xvautil.c	/^void main(int argc, char** argv)$/;"	f
map	move.c	/^int *head, *list, *map;  \/* arrays of integer *\/$/;"	v
mapSize	move.c	/^int NCell, mapSize, M;$/;"	v
maps	forces.c	/^void maps(void)$/;"	f
mass	nmpoly.h	/^double mass;$/;"	v
mathFlag	hetero.h	/^int heteroTraFlag = 1, heteroAngFlag = 1, mathFlag = 0;$/;"	v
maxGrey	hetero.h	/^int baseGrey = 20, maxGrey = 225;$/;"	v
maxwell	measures.c	/^void maxwell(void)$/;"	f
mdseed	nmpoly.h	/^  int mdseed; $/;"	m	struct:progStatus
measCalc	nmpoly.h	/^  int measCalc[NUM_MISURE]; \/*steps between two measure calculation *\/$/;"	m	struct:progStatus
measHead	nmpoly.h	/^struct measHead$/;"	s
measSteps	nmpoly.h	/^  int measSteps[NUM_MISURE];\/*steps after which save every measure *\/$/;"	m	struct:progStatus
mesh	init.c	/^int mesh[100][150][3];$/;"	v
mindist	init.c	/^double mindist(int ar, int ir)$/;"	f
mis	nmpoly.h	/^void* mis;$/;"	v
misPath	nmpoly.h	/^  char misPath[NAME_LENGTH];$/;"	m	struct:progStatus
mkFormat	hetero.c	/^void mkFormat(char* fmtStr)$/;"	f
mkFormat	jumps.c	/^void mkFormat(char* fmtStr)$/;"	f
mkFormat	wtd.c	/^void mkFormat(char* fmtStr)$/;"	f
mkFormat	xvautil.c	/^void mkFormat(char* fmtStr)$/;"	f
mkFormatMath	hetero.c	/^void mkFormatMath(char* fmtStr)$/;"	f
mobAngPerc	hetero.h	/^COORD_TYPE m0, m1, d, Vol, mobTraPerc, mobAngPerc;$/;"	v
mobTraPerc	hetero.h	/^COORD_TYPE m0, m1, d, Vol, mobTraPerc, mobAngPerc;$/;"	v
mode	nmpoly.h	/^  int mode;$/;"	m	struct:xvaHead
move	move.c	/^void move(void)$/;"	f
movea	move.c	/^void movea(COORD_TYPE dt, COORD_TYPE tol, int maxIt, int NB, COORD_TYPE d, $/;"	f
moveb	move.c	/^void moveb(COORD_TYPE dt, COORD_TYPE tol, int maxIt, int NB,$/;"	f
movebNPT	move.c	/^void movebNPT(COORD_TYPE dt, COORD_TYPE tol, int maxIt, int NB,$/;"	f
movebNTV	move.c	/^void movebNTV(COORD_TYPE dt, COORD_TYPE tol, int maxIt, int NB,$/;"	f
nRun	nmpoly.h	/^  char nRun[132];$/;"	m	struct:progStatus
nTeta	xvautil.h	/^int tCor, printEvery, nTeta, tBeg, Gsnr; $/;"	v
nebrNow	move.c	/^int **nebrTab, nebrNow, nebrTabLen, nebrTabMax;$/;"	v
nebrTab	move.c	/^int **nebrTab, nebrNow, nebrTabLen, nebrTabMax;$/;"	v
nebrTabFac	nmpoly.h	/^  int nebrTabFac;                \/* How much storage sould be provided for $/;"	m	struct:progStatus
nebrTabLen	move.c	/^int **nebrTab, nebrNow, nebrTabLen, nebrTabMax;$/;"	v
nebrTabMax	move.c	/^int **nebrTab, nebrNow, nebrTabLen, nebrTabMax;$/;"	v
noLinkedList	nmpoly.h	/^  int noLinkedList;              \/* If true use neighbour list method without$/;"	m	struct:progStatus
norm	xvautil.h	/^int *normv, *norm;$/;"	v
normv	xvautil.h	/^int *normv, *norm;$/;"	v
np	jumps.h	/^int tTot, printEvery, tBeg = 0, tgap, numParts, np[MP],$/;"	v
nsites	nmpoly.h	/^  int nsites;$/;"	m	struct:params
ntripl	init.c	/^int ntripl[100];$/;"	v
numParts	jumps.h	/^int tTot, printEvery, tBeg = 0, tgap, numParts, np[MP],$/;"	v
ohdr	corutil.c	/^int SEGSIZE, corBool = 0, tBool = 0, ihdr = 1, ohdr = 1, posBool = 0, Nm,$/;"	v
opar_ascii	nmpoly.h	/^struct pascii opar_ascii[]=$/;"	v
openMeasFile	hetero.c	/^int openMeasFile(char* FileName)$/;"	f
openMeasFile	jumps.c	/^int openMeasFile(char* FileName)$/;"	f
openMeasFile	wtd.c	/^int openMeasFile(char* FileName)$/;"	f
openMeasFile	xvautil.c	/^int openMeasFile(char* FileName)$/;"	f
opro_ascii	nmpoly.h	/^struct pascii opro_ascii[] =$/;"	v
outBool	corutil.c	/^int outBool = 0; \/* if true writes output coordinates file *\/$/;"	v
outFile	corutil.c	/^char outFile[NAME_LENGTH];  \/* output file (ascii file) name *\/$/;"	v
ox	move.c	/^COORD_TYPE *ox, *oy, *oz; \/* Angular velocities of each particle *\/$/;"	v
oy	move.c	/^COORD_TYPE *ox, *oy, *oz; \/* Angular velocities of each particle *\/$/;"	v
oz	move.c	/^COORD_TYPE *ox, *oy, *oz; \/* Angular velocities of each particle *\/$/;"	v
params	nmpoly.h	/^struct params$/;"	s
parnum	nmpoly.h	/^  int parnum;        	\/* particles number *\/$/;"	m	struct:params
parnum	nmpoly.h	/^  int parnum;$/;"	m	struct:xvaHead
phi0x	xvautil.h	/^COORD_TYPE *phix, *phiy, *phiz, *phi0x, *phi0y, *phi0z,$/;"	v
phi0y	xvautil.h	/^COORD_TYPE *phix, *phiy, *phiz, *phi0x, *phi0y, *phi0z,$/;"	v
phi0z	xvautil.h	/^COORD_TYPE *phix, *phiy, *phiz, *phi0x, *phi0y, *phi0z,$/;"	v
phiFile	xvautil.h	/^char phiFile[128]; \/* File containing the angular positions at all instants *\/$/;"	v
phiFlag	xvautil.h	/^  phiFlag=1, C4Flag=1, dphiSqFlag=1, drSqFlag=1, DtFlag=1, DrFlag=1, $/;"	v
phitt0x	xvautil.h	/^  *phitt0x, *phitt0y, *phitt0z;$/;"	v
phitt0y	xvautil.h	/^  *phitt0x, *phitt0y, *phitt0z;$/;"	v
phitt0z	xvautil.h	/^  *phitt0x, *phitt0y, *phitt0z;$/;"	v
phix	xvautil.h	/^COORD_TYPE *phix, *phiy, *phiz, *phi0x, *phi0y, *phi0z,$/;"	v
phiy	xvautil.h	/^COORD_TYPE *phix, *phiy, *phiz, *phi0x, *phi0y, *phi0z,$/;"	v
phiz	xvautil.h	/^COORD_TYPE *phix, *phiy, *phiz, *phi0x, *phi0y, *phi0z,$/;"	v
pi	hetero.h	/^COORD_TYPE pi;$/;"	v
pi	jumps.h	/^COORD_TYPE pi;$/;"	v
pi	move.c	/^COORD_TYPE pi, s1t, Vol1t, L, invL, s1p, Elrc, Plrc;   $/;"	v
pi	wtd.h	/^COORD_TYPE pi;$/;"	v
pi	xvautil.h	/^COORD_TYPE pi;$/;"	v
posBool	corutil.c	/^int SEGSIZE, corBool = 0, tBool = 0, ihdr = 1, ohdr = 1, posBool = 0, Nm,$/;"	v
posFile	corutil.c	/^char posFile[NAME_LENGTH];  \/* name of the positions file *\/$/;"	v
precision	hetero.h	/^char precision[64];$/;"	v
precision	jumps.h	/^char precision[64];$/;"	v
precision	nmpoly.h	/^char precision[64];         $/;"	v
precision	wtd.h	/^char precision[64];$/;"	v
precision	xvautil.h	/^char precision[64];$/;"	v
press	nmpoly.h	/^COORD_TYPE Vc, V, E, Dtrans, temp, S[NUMK], dummy, eta, Drot, gr[MAXBIN], invs, press,$/;"	v
press_at	nmpoly.h	/^  gr23[MAXBIN], gr33[MAXBIN], press_m, press_at;$/;"	v
press_m	nmpoly.h	/^  gr23[MAXBIN], gr33[MAXBIN], press_m, press_at;$/;"	v
printEvery	hetero.h	/^int greyLevel = 20, printEvery, tRun, DtTra, DtAng, DtTra_mean = 0, DtAng_mean = 0; $/;"	v
printEvery	jumps.h	/^int tTot, printEvery, tBeg = 0, tgap, numParts, np[MP],$/;"	v
printEvery	wtd.h	/^int printEvery, tRun, DtTra_star, DtAng_star, DtTra_mean = 0, DtAng_mean = 0; $/;"	v
printEvery	xvautil.h	/^int tCor, printEvery, nTeta, tBeg, Gsnr; $/;"	v
progStatus	nmpoly.h	/^struct progStatus$/;"	s
psi1File	xvautil.h	/^char velFile[128], psi1File[128], psi2File[128], C1File[128], C2File[128], $/;"	v
psi1Flag	xvautil.h	/^int velFlag=1, psi1Flag=1, psi2Flag=1, vhFlag=1, C1Flag=1, C2Flag=1, C3Flag=1,$/;"	v
psi1acf	xvautil.h	/^COORD_TYPE *velacf, *psi1acf, *psi2acf, *C1acf, *C2acf, *C3acf, $/;"	v
psi1c	nmpoly.h	/^  psi1c, psi2c, sqrtdr2, Aa, DrSqTot, DphiSq, GsAng[GSANGPOINT], Fs[FSPOINT],$/;"	v
psi2File	xvautil.h	/^char velFile[128], psi1File[128], psi2File[128], C1File[128], C2File[128], $/;"	v
psi2Flag	xvautil.h	/^int velFlag=1, psi1Flag=1, psi2Flag=1, vhFlag=1, C1Flag=1, C2Flag=1, C3Flag=1,$/;"	v
psi2acf	xvautil.h	/^COORD_TYPE *velacf, *psi1acf, *psi2acf, *C1acf, *C2acf, *C3acf, $/;"	v
psi2c	nmpoly.h	/^  psi1c, psi2c, sqrtdr2, Aa, DrSqTot, DphiSq, GsAng[GSANGPOINT], Fs[FSPOINT],$/;"	v
rCMt0x	hetero.h	/^COORD_TYPE RADFACT = 4.0, *rCMt0x, *rCMt0y,$/;"	v
rCMt0y	hetero.h	/^COORD_TYPE RADFACT = 4.0, *rCMt0x, *rCMt0y,$/;"	v
rCMt0z	hetero.h	/^  *rCMt0z, *rCMt1x, *rCMt1y, *rCMt1z;$/;"	v
rCMt1x	hetero.h	/^  *rCMt0z, *rCMt1x, *rCMt1y, *rCMt1z;$/;"	v
rCMt1y	hetero.h	/^  *rCMt0z, *rCMt1x, *rCMt1y, *rCMt1z;$/;"	v
rCMt1z	hetero.h	/^  *rCMt0z, *rCMt1x, *rCMt1y, *rCMt1z;$/;"	v
rNebrShell	nmpoly.h	/^  COORD_TYPE rNebrShell;         \/* = Dr see Rapaport pag. 53 *\/$/;"	m	struct:progStatus
radDens	measures.c	/^void radDens(void)$/;"	f
radDens23	measures.c	/^void radDens23(void)$/;"	f
radDens33	measures.c	/^void radDens33(void)$/;"	f
ranf	init.c	/^COORD_TYPE ranf(void)$/;"	f
rcut	nmpoly.h	/^  COORD_TYPE rcut;              \/* cutoff for the pair potential *\/ $/;"	m	struct:params
readAllCor	init.c	/^void readAllCor(FILE* fs)$/;"	f
readMeas	hetero.c	/^int readMeas(int fd, int nmeas, COORD_TYPE* firstPtr, ...)$/;"	f
readMeas	jumps.c	/^int readMeas(int fd, int nmeas, COORD_TYPE* firstPtr, ...)$/;"	f
readMeas	wtd.c	/^int readMeas(int fd, int nmeas, COORD_TYPE* firstPtr, ...)$/;"	f
readMeas	xvautil.c	/^int readMeas(int fd, int nmeas, COORD_TYPE* firstPtr, ...)$/;"	f
readPars	hetero.c	/^void readPars(char* fileName)$/;"	f
readPars	jumps.c	/^void readPars(char* fileName)$/;"	f
readPars	wtd.c	/^void readPars(char* fileName)$/;"	f
readPars	xvautil.c	/^void readPars(char* fileName)$/;"	f
resetCM	init.c	/^void resetCM(int Nm)$/;"	f
rotDiff	measures.c	/^void rotDiff(void)$/;"	f
rxCMi	nmpoly.h	/^  COORD_TYPE rxCMi[MAXPAR]; \/* initial coordinates of center of mass *\/$/;"	m	struct:progStatus
rx_old	init.c	/^double **rx_old, **ry_old, **rz_old, **vxold, **vyold, **vzold, **sigmag;$/;"	v
ryCMi	nmpoly.h	/^  COORD_TYPE ryCMi[MAXPAR]; \/* MAXPAR is the maximum number of particles *\/$/;"	m	struct:progStatus
ry_old	init.c	/^double **rx_old, **ry_old, **rz_old, **vxold, **vyold, **vzold, **sigmag;$/;"	v
rzCMi	nmpoly.h	/^  COORD_TYPE rzCMi[MAXPAR];$/;"	m	struct:progStatus
rz_old	init.c	/^double **rx_old, **ry_old, **rz_old, **vxold, **vyold, **vzold, **sigmag;$/;"	v
s1p	move.c	/^COORD_TYPE pi, s1t, Vol1t, L, invL, s1p, Elrc, Plrc;   $/;"	v
s1t	move.c	/^COORD_TYPE pi, s1t, Vol1t, L, invL, s1p, Elrc, Plrc;   $/;"	v
sResetSteps	nmpoly.h	/^  int sResetSteps; \/* Steps at which reset s to 1 *\/$/;"	m	struct:progStatus
saveAcf	xvautil.c	/^void saveAcf(char* fileName, COORD_TYPE* acf)$/;"	f
saveFself	xvautil.c	/^void saveFself(char* fileName, COORD_TYPE* fs)$/;"	f
saveFunc	jumps.c	/^void saveFunc(char* fileName, COORD_TYPE* acf, int mShift)$/;"	f
saveGself	xvautil.c	/^void saveGself(char* fileName, COORD_TYPE** gs)$/;"	f
saveSteps	nmpoly.h	/^  int saveSteps; \/* save between two tape savings *\/$/;"	m	struct:xvaHead
saveSteps	nmpoly.h	/^  int saveSteps;$/;"	m	struct:measHead
saveVH	xvautil.c	/^void saveVH(char *fileName, COORD_TYPE** vh)$/;"	f
save_hetero	hetero.c	/^void save_hetero(char* fileName, COORD_TYPE* sqrtDisp, int* mobileLst, $/;"	f
save_wtd	wtd.c	/^void save_wtd(char* fileName, int* wtdArr, int tBeg)$/;"	f
savedXva	nmpoly.h	/^  int savedXva;$/;"	m	struct:progStatus
savesnap	move.c	/^void savesnap(void)$/;"	f
scalCor	move.c	/^void scalCor(int Nm)$/;"	f
setFlags	hetero.c	/^void setFlags(void)$/;"	f
setFlags	wtd.c	/^void setFlags(void)$/;"	f
setFlags	xvautil.c	/^void setFlags(void)$/;"	f
shakeVel	move.c	/^void shakeVel(int Nm, COORD_TYPE dt, COORD_TYPE m[NA], int maxIt, int NB, $/;"	f
sigma	nmpoly.h	/^  double sigma;$/;"	m	struct:params
sigmag	init.c	/^double **rx_old, **ry_old, **rz_old, **vxold, **vyold, **vzold, **sigmag;$/;"	v
size	nmpoly.h	/^  int size ;     \/* size of each xva savings = $/;"	m	struct:xvaHead
size	nmpoly.h	/^  int size;  \/* size in bytes of each measure *\/$/;"	m	struct:measHead
snapSteps	nmpoly.h	/^  int snapSteps;$/;"	m	struct:progStatus
snapmode	nmpoly.h	/^  int snapmode;$/;"	m	struct:progStatus
sqrtdr2	nmpoly.h	/^  psi1c, psi2c, sqrtdr2, Aa, DrSqTot, DphiSq, GsAng[GSANGPOINT], Fs[FSPOINT],$/;"	v
sqrtdr2File	jumps.h	/^char inputFile[NAME_LENGTH], xvaparsFile[NAME_LENGTH], sqrtdr2File[255], $/;"	v
staSteps	nmpoly.h	/^  int staSteps;     \/* steps after which must save sim_stat structure $/;"	m	struct:progStatus
steplength	nmpoly.h	/^  COORD_TYPE steplength;		\/* temporal step length *\/$/;"	m	struct:params
sumEta	nmpoly.h	/^  COORD_TYPE sumEta; \/* accumulators for obtaining the mean value of eta *\/$/;"	m	struct:progStatus
sumPress	nmpoly.h	/^  COORD_TYPE sumPress;$/;"	m	struct:progStatus
sumS	nmpoly.h	/^  COORD_TYPE sumS[NUMK];$/;"	m	struct:progStatus
sumSquared	hetero.c	/^COORD_TYPE sumSquared(COORD_TYPE* sqrtDisp, int Nm)$/;"	f
sumTemp	nmpoly.h	/^  COORD_TYPE sumTemp;$/;"	m	struct:progStatus
sumox	nmpoly.h	/^  COORD_TYPE sumox[MAXPAR];$/;"	m	struct:progStatus
sumoy	nmpoly.h	/^  COORD_TYPE sumoy[MAXPAR];$/;"	m	struct:progStatus
sumoz	nmpoly.h	/^  COORD_TYPE sumoz[MAXPAR];$/;"	m	struct:progStatus
t0	hetero.h	/^int t0;$/;"	v
tBeg	jumps.h	/^int tTot, printEvery, tBeg = 0, tgap, numParts, np[MP],$/;"	v
tBeg	xvautil.h	/^int tCor, printEvery, nTeta, tBeg, Gsnr; $/;"	v
tBool	corutil.c	/^int SEGSIZE, corBool = 0, tBool = 0, ihdr = 1, ohdr = 1, posBool = 0, Nm,$/;"	v
tCor	xvautil.h	/^int tCor, printEvery, nTeta, tBeg, Gsnr; $/;"	v
tRun	hetero.h	/^int greyLevel = 20, printEvery, tRun, DtTra, DtAng, DtTra_mean = 0, DtAng_mean = 0; $/;"	v
tRun	wtd.h	/^int printEvery, tRun, DtTra_star, DtAng_star, DtTra_mean = 0, DtAng_mean = 0; $/;"	v
tTot	jumps.h	/^int tTot, printEvery, tBeg = 0, tgap, numParts, np[MP],$/;"	v
tapeTimes	nmpoly.h	/^  int tapeTimes;    \/* every 'tapeTimes * Omeasure[].saveSteps' $/;"	m	struct:progStatus
temp	nmpoly.h	/^COORD_TYPE Vc, V, E, Dtrans, temp, S[NUMK], dummy, eta, Drot, gr[MAXBIN], invs, press,$/;"	v
temp_transl	nmpoly.h	/^  GsGsg[GSPOINT], temp_transl;$/;"	v
temperat	measures.c	/^void temperat(void)$/;"	f
tetaFile	jumps.h	/^tetaFile[255];$/;"	v
tgap	jumps.h	/^int tTot, printEvery, tBeg = 0, tgap, numParts, np[MP],$/;"	v
tgap	xvautil.h	/^int tgap; \/* Increment of t0 *\/$/;"	v
tmpPath	nmpoly.h	/^  char tmpPath[NAME_LENGTH];$/;"	m	struct:progStatus
tol	nmpoly.h	/^  COORD_TYPE tol;               \/* Tolerance of the shake algoritm used $/;"	m	struct:params
tolVol	nmpoly.h	/^  COORD_TYPE tolVol;$/;"	m	struct:progStatus
tolVol1	nmpoly.h	/^  COORD_TYPE tolVol1;$/;"	m	struct:progStatus
tols	nmpoly.h	/^  COORD_TYPE tols;$/;"	m	struct:progStatus
totStep	nmpoly.h	/^  int totStep;	\/* temporal step number that simulation $/;"	m	struct:params
transDiff	measures.c	/^void transDiff(void)$/;"	f
updateAng	move.c	/^void updateAng(int Nm)$/;"	f
updateDQ	move.c	/^void updateDQ(COORD_TYPE dt)$/;"	f
update_sigmas	init.c	/^void update_sigmas(void)$/;"	f
usrInitAft	init.c	/^void usrInitAft(void)$/;"	f
usrInitBef	init.c	/^void usrInitBef(void)$/;"	f
ux	move.c	/^COORD_TYPE *ux, *uy, *uz; \/* Molecular orientations *\/$/;"	v
uy	move.c	/^COORD_TYPE *ux, *uy, *uz; \/* Molecular orientations *\/$/;"	v
uz	move.c	/^COORD_TYPE *ux, *uy, *uz; \/* Molecular orientations *\/$/;"	v
vanHove	xvautil.h	/^COORD_TYPE **vanHove;$/;"	v
vectProd	hetero.c	/^void vectProd(COORD_TYPE r1x, COORD_TYPE r1y, COORD_TYPE r1z, $/;"	f
vectProd	init.c	/^void vectProd(COORD_TYPE r1x, COORD_TYPE r1y, COORD_TYPE r1z, $/;"	f
vectProd	wtd.c	/^void vectProd(COORD_TYPE r1x, COORD_TYPE r1y, COORD_TYPE r1z, $/;"	f
vectProd	xvautil.c	/^void vectProd(COORD_TYPE r1x, COORD_TYPE r1y, COORD_TYPE r1z, $/;"	f
velFile	xvautil.h	/^char velFile[128], psi1File[128], psi2File[128], C1File[128], C2File[128], $/;"	v
velFlag	xvautil.h	/^int velFlag=1, psi1Flag=1, psi2Flag=1, vhFlag=1, C1Flag=1, C2Flag=1, C3Flag=1,$/;"	v
velacf	xvautil.h	/^COORD_TYPE *velacf, *psi1acf, *psi2acf, *C1acf, *C2acf, *C3acf, $/;"	v
velc	nmpoly.h	/^COORD_TYPE Ptens[3], DQtens[3], C1c, C2c, C3c, C4c, velc, Gs[GSPOINT], $/;"	v
vhFile	xvautil.h	/^  DrFile[128], vhFile[128], ddtdrFile[128], ddtdphiFile[128],$/;"	v
vhFlag	xvautil.h	/^int velFlag=1, psi1Flag=1, psi2Flag=1, vhFlag=1, C1Flag=1, C2Flag=1, C3Flag=1,$/;"	v
vhgap	xvautil.h	/^int vhgap; \/* steps every which save the van Hove function *\/$/;"	v
viscosity	measures.c	/^void viscosity(void)$/;"	f
vxold	init.c	/^double **rx_old, **ry_old, **rz_old, **vxold, **vyold, **vzold, **sigmag;$/;"	v
vyold	init.c	/^double **rx_old, **ry_old, **rz_old, **vxold, **vyold, **vzold, **sigmag;$/;"	v
vzold	init.c	/^double **rx_old, **ry_old, **rz_old, **vxold, **vyold, **vzold, **sigmag;$/;"	v
wp	jumps.h	/^char wp[1024];$/;"	v
writeAllCor	init.c	/^void writeAllCor(FILE* fs)$/;"	f
wtd	xvautil.h	/^  *C4acf, *wtd;$/;"	v
wtdAng	wtd.h	/^int *wtdTra, *wtdAng;$/;"	v
wtdAngFile	wtd.h	/^char wtdAngFile[128], wtdTraFile[128];$/;"	v
wtdAngFlag	wtd.h	/^int wtdTraFlag = 1, wtdAngFlag = 1;$/;"	v
wtdFile	xvautil.h	/^  wtdFile[128];$/;"	v
wtdFlag	xvautil.h	/^  GsGsgaussFlag = 1, FselfFlag = 1, wtdFlag = 1;$/;"	v
wtdRmax	xvautil.h	/^COORD_TYPE m0, m1, d, Vol, GsrMax, wtdRmax, kMax;$/;"	v
wtdTra	wtd.h	/^int *wtdTra, *wtdAng;$/;"	v
wtdTraFile	wtd.h	/^char wtdAngFile[128], wtdTraFile[128];$/;"	v
wtdTraFlag	wtd.h	/^int wtdTraFlag = 1, wtdAngFlag = 1;$/;"	v
xvaHead	nmpoly.h	/^struct xvaHead $/;"	s
xvaParsing	hetero.c	/^void xvaParsing(char stringA[NAME_LENGTH], char stringB[NAME_LENGTH])$/;"	f
xvaParsing	jumps.c	/^void xvaParsing(char stringA[NAME_LENGTH], char stringB[NAME_LENGTH])$/;"	f
xvaParsing	wtd.c	/^void xvaParsing(char stringA[NAME_LENGTH], char stringB[NAME_LENGTH])$/;"	f
xvaParsing	xvautil.c	/^void xvaParsing(char stringA[NAME_LENGTH], char stringB[NAME_LENGTH])$/;"	f
xvaSaveMode	nmpoly.h	/^  int xvaSaveMode;\/* 0 = linear 1 = semilog 2 = bilog (not impl. yet) *\/$/;"	m	struct:progStatus
xvaSteps	nmpoly.h	/^  int xvaSteps;     \/* steps between two tape file savings *\/$/;"	m	struct:progStatus
xvadt	hetero.h	/^COORD_TYPE Mtot, xvadt, dt, dteta, T; \/* T = temperature *\/$/;"	v
xvadt	jumps.h	/^COORD_TYPE xvadt, dt;$/;"	v
xvadt	wtd.h	/^COORD_TYPE Mtot, xvadt, dt, dteta, T; \/* T = temperature *\/$/;"	v
xvadt	xvautil.h	/^COORD_TYPE Mtot, xvadt, dt, dteta, T; \/* T = temperature *\/$/;"	v
xvafile	nmpoly.h	/^  char xvafile[NAME_LENGTH]; \/* file containing positions, velocities and $/;"	m	struct:progStatus
xvaparsFile	hetero.h	/^char inputFile[NAME_LENGTH], xvaparsFile[NAME_LENGTH];$/;"	v
xvaparsFile	jumps.h	/^char inputFile[NAME_LENGTH], xvaparsFile[NAME_LENGTH], sqrtdr2File[255], $/;"	v
xvaparsFile	wtd.h	/^char inputFile[NAME_LENGTH], xvaparsFile[NAME_LENGTH];$/;"	v
xvaparsFile	xvautil.h	/^char inputFile[NAME_LENGTH], xvaparsFile[NAME_LENGTH];$/;"	v
zeroJump	wtd.c	/^void zeroJump(void)$/;"	f
